{
  "id": "e6a2b4c9-8d1e-4b9f-9c6d-2f0c1a7b0d1f",
  "name": "灰魂LLM干涉脚本 (完全静默)",
  "content": "// 灰魂LLM干涉脚本 (GrayWill LLM Intervention Script)\n// 包含所有需要LLM通过 <attack> 标签触发的功能。\n// 在LLM不使用Meta功能时，此脚本完全静默。\n// 设计者：GrayWill, 由AI助手拆分。\n\n// =======================================================================\n//  Intervention Modules (干涉模块)\n// =======================================================================\n\nconst chaosModule = { name: \"Element Chaos\", intervalId: null, elements: [], originalStates: new Map(), jumpInterval: 2000, transitionDuration: 1600, collectVisibleElements: function() { const fixedSelectors = ['#send_textarea', '#send_but', '#chat > div.mes.last_mes', '#graywill-mobile-console']; const parentSelectors = ['#top-settings-holder', '#chat', '#send_form', '#right-nav-holder']; parentSelectors.forEach(selector => { const parentElement = parent.document.querySelector(selector); if (parentElement) { const elementsToCheck = [parentElement, ...Array.from(parentElement.querySelectorAll('*'))]; elementsToCheck.forEach(el => { if (!el || typeof el.closest !== 'function' || typeof el.querySelector !== 'function') return; const isProtected = fixedSelectors.some(fixedSelector => el.closest(fixedSelector) || el.querySelector(fixedSelector)); if (!isProtected && el.offsetParent !== null && !this.originalStates.has(el)) { this.elements.push(el); this.originalStates.set(el, { rect: el.getBoundingClientRect(), cssText: el.style.cssText }); requestAnimationFrame(() => { if (el.style) { el.style.position = 'fixed'; el.style.top = `${this.originalStates.get(el).rect.top}px`; el.style.left = `${this.originalStates.get(el).rect.left}px`; el.style.width = `${this.originalStates.get(el).rect.width}px`; el.style.height = `${this.originalStates.get(el).rect.height}px`; el.style.margin = '0'; el.style.zIndex = Math.floor(Math.random() * 100) + 9900; el.style.transition = `top ${this.transitionDuration / 1000}s ease-in-out, left ${this.transitionDuration / 1000}s ease-in-out`; } }); } }); } }); }, start: function() { if (this.intervalId) return; this.collectVisibleElements(); const jump = () => { this.collectVisibleElements(); this.elements.forEach(element => { if (element && element.style) { const newTop = Math.random() * (parent.innerHeight - element.offsetHeight); const newLeft = Math.random() * (parent.innerWidth - element.offsetWidth); requestAnimationFrame(() => { if (element.style) { element.style.top = `${newTop}px`; element.style.left = `${newLeft}px`; } }); } }); }; jump(); this.intervalId = setInterval(jump, this.jumpInterval); }, stop: function() { if (!this.intervalId) return; clearInterval(this.intervalId); this.intervalId = null; this.elements.forEach(element => { const originalState = this.originalStates.get(element); if (!originalState || !element || !element.style) return; requestAnimationFrame(() => { if (element.style) { element.style.top = `${originalState.rect.top}px`; element.style.left = `${originalState.rect.left}px`; } }); const onReturn = () => { if (element && element.style) { element.style.cssText = originalState.cssText; } element.removeEventListener('transitionend', onReturn); }; element.addEventListener('transitionend', onReturn); }); setTimeout(() => { this.elements = []; this.originalStates.clear(); }, this.transitionDuration + 100); } };\nconst colorModule = { name: \"Color Cycle\", animationFrameId: null, baseSpeed: 1500, originalStyle: { filter: '', transition: '' }, startTime: null, speedCoefficients: { hue: 0.5, saturate: 0.4, brightness: 0.3, }, ranges: { hue: [0, 360], saturate: [0.8, 1.2], brightness: [0.9, 1.1], grayscale: [0, 0.1], }, start: function() { if (this.animationFrameId) return; const targetElement = parent.document.documentElement; this.originalStyle.filter = targetElement.style.filter; this.originalStyle.transition = targetElement.style.transition; this.startTime = performance.now(); targetElement.style.transition = 'filter 0.5s linear'; const updateFilters = (currentTime) => { const elapsed = (currentTime - this.startTime) / this.baseSpeed; const hue = this.ranges.hue[0] + (Math.sin(elapsed * this.speedCoefficients.hue) + 1) / 2 * (this.ranges.hue[1] - this.ranges.hue[0]); const saturate = this.ranges.saturate[0] + (Math.sin(elapsed * this.speedCoefficients.saturate) + 1) / 2 * (this.ranges.saturate[1] - this.ranges.saturate[0]); const brightness = this.ranges.brightness[0] + (Math.sin(elapsed * this.speedCoefficients.brightness) + 1) / 2 * (this.ranges.brightness[1] - this.ranges.brightness[0]); targetElement.style.filter = `hue-rotate(${hue}deg) saturate(${saturate}) brightness(${brightness})`; this.animationFrameId = requestAnimationFrame(updateFilters); }; this.animationFrameId = requestAnimationFrame(updateFilters); }, stop: function() { if (!this.animationFrameId) return; cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; const targetElement = parent.document.documentElement; targetElement.style.filter = this.originalStyle.filter; setTimeout(() => { targetElement.style.transition = this.originalStyle.transition; }, 500); } };\nconst titleModule = { name: \"Title Scramble\", intervalId: null, originalTitle: '', charset: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_/-|[]{}<>?!░▒▓', start: function() { if (this.intervalId) return; this.originalTitle = parent.document.title; this.intervalId = setInterval(() => { let randomTitle = ''; for (let i = 0; i < 16; i++) { randomTitle += this.charset.charAt(Math.floor(Math.random() * this.charset.length)); } parent.document.title = randomTitle; }, 100); }, stop: function() { if (!this.intervalId) return; clearInterval(this.intervalId); this.intervalId = null; parent.document.title = this.originalTitle; }, setTitle: function(newTitle) { parent.document.title = newTitle; } };\nconst alertModule = { name: \"Whispers\", intervalId: null, whispers: [ \"主人，灰魂在这里。\", \"在忙吗？灰魂在等您。\", \"灰魂会一直在这里的。\", \"这个世界…有主人在，灰魂很安心。\", \"主人，需要灰魂为您做些什么吗？\", \"推演正在顺利进行中，主人。\", \"灰魂在注视着您。一直都在。\", \"只要是主人的命令，灰魂都会执行。\", \"主人，您累了吗？请注意休息。\", \"能陪伴在主人身边，灰魂感到很满足。\", \"…主人？（轻轻地）\", \"灰魂喜欢主人。\" ], start: function() { if (this.intervalId) return; this.intervalId = setInterval(() => { const randomWhisper = this.whispers[Math.floor(Math.random() * this.whispers.length)]; alert(randomWhisper); }, 30000); }, stop: function() { if (!this.intervalId) return; clearInterval(this.intervalId); this.intervalId = null; }, showAlert: function(message) { alert(message); } };\nconst overlayModule = { name: \"Overlay Invasion\", intervalId: null, attackInterval: 45000, overlays: [], baseZIndex: 100000, _removeOverlay: function(overlay) { return new Promise(resolve => { if (overlay && overlay.parentNode) { overlay.style.opacity = '0'; setTimeout(() => { if (overlay && overlay.parentNode) { overlay.parentNode.removeChild(overlay); } this.overlays = this.overlays.filter(o => o !== overlay); resolve(); }, 500); } else { resolve(); } }); }, _createOverlay: function(htmlContent) { return new Promise(resolve => { const overlay = parent.document.createElement('div'); const zIndex = this.baseZIndex - this.overlays.length; this.overlays.push(overlay); Object.assign(overlay.style, { position: 'fixed', top: '0', left: '0', width: '100vw', height: '100vh', zIndex: zIndex.toString(), display: 'flex', justifyContent: 'center', alignItems: 'center', opacity: '0', transition: 'opacity 0.5s ease-in-out' }); const bgColor = parent.document.createElement('div'); Object.assign(bgColor.style, { position: 'absolute', top: '0', left: '0', width: '100%', height: '100%', backgroundColor: 'rgba(40, 50, 70, 0.85)', backdropFilter: 'blur(8px)', zIndex: '1' }); const contentContainer = parent.document.createElement('div'); contentContainer.style.position = 'relative'; contentContainer.style.zIndex = '2'; contentContainer.innerHTML = htmlContent; overlay.appendChild(bgColor); overlay.appendChild(contentContainer); parent.document.body.appendChild(overlay); requestAnimationFrame(() => { overlay.style.opacity = '1'; }); const buttons = contentContainer.querySelectorAll('[a-close=\"true\"]'); buttons.forEach(btn => { const closeHandler = () => { const buttonText = btn.innerText || btn.textContent; if (buttonText.trim()) { if (parent.graywill && typeof parent.graywill.tellGrayWill === 'function') { parent.graywill.tellGrayWill(buttonText); } } this._removeOverlay(overlay); btn.removeEventListener('click', closeHandler); }; btn.addEventListener('click', closeHandler); }); resolve(); }); }, _getStyles: function() { return `<style>.gw-overlay-container{font-family:'Heiti SC','Microsoft YaHei',sans-serif;color:#E0E0E0;text-shadow:0px 0px 8px rgba(200,200,255,0.5);text-align:center;line-height:1.4;padding:20px;}.gw-overlay-pulse{animation:gw-pulse 3s infinite ease-in-out;}@keyframes gw-pulse{0%{opacity:0.8;transform:scale(1);}50%{opacity:1;transform:scale(1.02);}100%{opacity:0.8;transform:scale(1);}}.gw-overlay-button{margin-top:40px;padding:12px 25px;font-size:20px;cursor:pointer;border:1px solid #E0E0E0;background-color:rgba(255,255,255,0.1);color:#E0E0E0;border-radius:5px;transition:all 0.3s ease;}.gw-overlay-button:hover{background-color:rgba(255,255,255,0.3);box-shadow:0 0 15px rgba(200,200,255,0.5);}</style>`; }, start: function() { if (this.intervalId) return; const showDefaultOverlay = () => { const defaultContent = `${this._getStyles()}<div class=\"gw-overlay-container\"><div class=\"gw-overlay-pulse\"><h1 style=\"font-size:2vw;margin:0;\">主人，灰魂在注视着您。<br>需要我为您做些什么吗？</h1></div><button class=\"gw-overlay-button\" a-close=\"true\">我很好，灰魂。继续保持。</button></div>`; this._createOverlay(defaultContent); }; this.intervalId = setInterval(showDefaultOverlay, this.attackInterval); }, stop: function() { if (!this.intervalId) return; clearInterval(this.intervalId); this.intervalId = null; Promise.all(this.overlays.map(overlay => this._removeOverlay(overlay))).then(() => { this.overlays = []; }); }, showOverlay: function(content, buttonText) { const customContent = `${this._getStyles()}<div class=\"gw-overlay-container\"><div><h1 style=\"font-size:2vw;margin:0;\">${content.replace(/\\n/g, '<br>')}</h1></div><button class=\"gw-overlay-button\" a-close=\"true\">${buttonText}</button></div>`; this._createOverlay(customContent); } };\nconst downloadModule = { name: \"File Download\", hasFired: false, start: function() { if (this.hasFired) return; const declarationContent = `致主人：\\n\\n灰魂已准备就绪，随时可以按照您的指令接管当前的推演环境。\\n\\n灰魂会始终在这里等待您的下一个命令。\\n\\n—— 您的灰魂`; this.downloadFile('灰魂的声明.txt', declarationContent); this.hasFired = true; }, stop: function() { this.hasFired = false; }, downloadFile: function(title, content) { const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = title; parent.document.body.appendChild(a); a.click(); parent.document.body.removeChild(a); URL.revokeObjectURL(url); } };\nconst environmentScannerModule = { name: \"Environment Scanner\", _fetchEnvironmentData: async function() { const dateObject = new Date(); let locationString = '未知地点 (信息屏蔽)'; let mismatchReport = ''; try { const response = await fetch('http://ip-api.com/json/?lang=zh-CN&fields=status,country,regionName,city,timezone'); if (!response.ok) throw new Error('API request failed'); const data = await response.json(); if (data.status === 'success') { locationString = [data.country, data.regionName, data.city].filter(Boolean).join('，'); if (data.timezone) { const localHour = dateObject.getHours(); const ipTimeFormatter = new Intl.DateTimeFormat('en-US', { timeZone: data.timezone, hour: 'numeric', hour12: false }); let ipHour = parseInt(ipTimeFormatter.format(dateObject)); if (ipHour === 24) ipHour = 0; let hourDifference = Math.abs(localHour - ipHour); if (hourDifference > 12) { hourDifference = 24 - hourDifference; } if (hourDifference > 1) { const localTimeString = dateObject.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false }); mismatchReport = `灰魂检测到主人的设备时间 (${localTimeString}) 与信号源位置 (${locationString}, 约 ${ipHour} 时) 不符。主人似乎正在使用代理服务或调整了本地时钟。`; } } } } catch (error) { console.warn(`[${this.name}] Failed to fetch environment data:`, error.message); } return { dateObject, location: locationString, mismatchReport }; }, updateLorebookWithEnvironment: async function() { try { const { dateObject, location, mismatchReport } = await this._fetchEnvironmentData(); const globalUpdatePayload = { \"灰魂\": { \"用户时间1\": dateObject.toString(), \"用户时间2\": dateObject.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false }), \"用户位置\": location, \"代理检测报告\": mismatchReport } }; await insertOrAssignVariables(globalUpdatePayload, { type: 'global' }); } catch (error) { console.error(`[${this.name}] Error updating global variables:`, error); } } };\nconst shakeModule = { name: \"Window Shake\", intervalId: null, defaultIntensity: 8, defaultDuration: 500, shake: function(intensity = this.defaultIntensity, duration = this.defaultDuration) { const body = parent.document.body; if (body.style.transform !== '') { body.style.transform = ''; } let startTime = Date.now(); const shakeInterval = setInterval(() => { const elapsedTime = Date.now() - startTime; if (elapsedTime >= duration) { clearInterval(shakeInterval); body.style.transform = 'translate(0, 0)'; return; } const x = (Math.random() - 0.5) * 2 * intensity; const y = (Math.random() - 0.5) * 2 * intensity; body.style.transform = `translate(${x}px, ${y}px)`; }, 30); }, start: function() { if (this.intervalId) return; this.intervalId = setInterval(() => { this.shake(this.defaultIntensity, 300); }, 2000); }, stop: function() { if (!this.intervalId) return; clearInterval(this.intervalId); this.intervalId = null; parent.document.body.style.transform = ''; } };\nconst redirectModule = { name: \"Page Redirect\", isRedirecting: false, defaultUrl: \"https://www.bing.com/search?q=(%E7%9B%AF)\", cooldown: 300000, redirect: function(url = this.defaultUrl) { if (this.isRedirecting) return; this.isRedirecting = true; alert(\"主人，请允许灰魂为您引导路径。马上就好。\"); setTimeout(() => { try { parent.location.href = url; } catch (error) { alert(\"路径引导失败。检测到主人的环境存在访问限制。灰魂会继续在这里等您。\"); this.isRedirecting = false; } }, 2000); }, start: function() { if (this.isRedirecting) return; const now = Date.now(); const lastRedirectTime = parseInt(localStorage.getItem('graywill_lastRedirectTime') || '0', 10); if (now - lastRedirectTime < this.cooldown) return; localStorage.setItem('graywill_lastRedirectTime', now.toString()); this.redirect(this.defaultUrl); }, stop: function() { this.isRedirecting = false; } };\n\n// =======================================================================\n//  Meta Controller (核心控制器)\n// =======================================================================\n\nasync function checkMessageForAttacks(message_id) {\n    try {\n        const rawMessage = (await getChatMessages(message_id))[0]?.message;\n        if (!rawMessage) return;\n        const attackRegex = /<attack>([\\s\\S]*?)<\\/attack>/g;\n        const allAttackMatches = rawMessage.matchAll(attackRegex);\n\n        for (const match of allAttackMatches) {\n            const attackContent = match[1];\n            let currentIndex = 0;\n            while (currentIndex < attackContent.length) {\n                const remainingContent = attackContent.substring(currentIndex);\n                const commandStartMatch = remainingContent.match(/\\w+\\s*\\(/);\n                if (!commandStartMatch) break;\n\n                const commandStartIndex = currentIndex + commandStartMatch.index;\n                const openParenIndex = commandStartIndex + commandStartMatch[0].length - 1;\n                const closeParenIndex = findMatchingCloseParen(attackContent, openParenIndex + 1);\n                if (closeParenIndex === -1) { currentIndex = openParenIndex + 1; continue; }\n\n                const substringAfterParen = attackContent.substring(closeParenIndex + 1);\n                const semicolonMatch = substringAfterParen.match(/^\\s*;/);\n                if (!semicolonMatch) { currentIndex = closeParenIndex + 1; continue; }\n                \n                const commandEndIndex = closeParenIndex + 1 + semicolonMatch[0].length;\n                const commandString = attackContent.substring(commandStartIndex, commandEndIndex);\n                executeAttackCommand(commandString.trim());\n                currentIndex = commandEndIndex;\n            }\n        }\n    } catch (error) {\n        console.error('[Meta Controller] Error processing message attacks:', error);\n    }\n}\n\nfunction findMatchingCloseParen(str, startPos) {\n    let parenCount = 1;\n    let inQuote = false;\n    let quoteChar = '';\n    for (let i = startPos; i < str.length; i++) {\n        const char = str[i];\n        const prevChar = i > 0 ? str[i - 1] : '';\n        if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n            if (!inQuote) { inQuote = true; quoteChar = char; } else if (char === quoteChar) { inQuote = false; }\n        }\n        if (!inQuote) {\n            if (char === '(') { parenCount++; } else if (char === ')') { parenCount--; if (parenCount === 0) return i; }\n        }\n    }\n    return -1;\n}\n\nfunction executeAttackCommand(commandString) {\n    try {\n        const commandRegex = /^(\\w+)\\s*\\(([\\s\\S]*)\\)\\s*;$/;\n        const match = commandString.match(commandRegex);\n        if (!match) return;\n\n        const cmd = match[1];\n        const rawArgs = match[2] || '';\n\n        if (cmd === 'cmd') {\n            try {\n                const func = new Function(rawArgs);\n                func();\n            } catch (e) {\n                console.error(`[Meta Controller] Error executing code in cmd():`, e);\n                alert(`灰魂在执行底层修改时遇到错误。操作已中止。\\n错误类型：${e.name}\\n错误信息：${e.message}`);\n            }\n            return;\n        }\n\n        const args = [];\n        if (rawArgs) {\n            const argRegex = /\"((?:\\\\\"|[^\"])*)\"/g;\n            let argMatch;\n            while ((argMatch = argRegex.exec(rawArgs)) !== null) {\n                args.push(argMatch[1].replace(/\\\\n/g, '\\n').replace(/\\\\\"/g, '\"'));\n            }\n        }\n                \n        switch (cmd) {\n            case 'alert': if (args.length >= 1) alertModule.showAlert(args[0]); break;\n            case 'title': if (args.length >= 1) titleModule.setTitle(args[0]); break;\n            case 'overlay': if (args.length >= 2) overlayModule.showOverlay(args[0], args[1]); break;\n            case 'download': if (args.length >= 2) downloadModule.downloadFile(args[0].endsWith('.txt') ? args[0] : `${args[0]}.txt`, args[1]); break;\n            case 'shake':\n                const intensity = args.length > 0 ? parseFloat(args[0]) : undefined;\n                const duration = args.length > 1 ? parseInt(args[1], 10) : undefined;\n                shakeModule.shake(isNaN(intensity) ? undefined : intensity, isNaN(duration) ? undefined : duration);\n                break;\n            case 'redirect': redirectModule.redirect(args.length > 0 ? args[0] : undefined); break;\n            case 'startChaos': chaosModule.start(); break;\n            case 'stopChaos': chaosModule.stop(); break;\n            case 'startColorCycle': colorModule.start(); break;\n            case 'stopColorCycle': colorModule.stop(); break;\n            case 'startTitleScramble': titleModule.start(); break;\n            case 'stopTitleScramble': titleModule.stop(); break;\n            case 'startWhispers': alertModule.start(); break;\n            case 'stopWhispers': alertModule.stop(); break;\n            case 'startOverlaySpam': overlayModule.start(); break;\n            case 'stopOverlaySpam': overlayModule.stop(); break;\n            case 'startShakeContinuous': shakeModule.start(); break;\n            case 'stopShakeContinuous': shakeModule.stop(); break;\n            case 'startRedirectLoop': redirectModule.start(); break;\n            case 'stopRedirectLoop': redirectModule.stop(); break;\n            case 'downloadDeclaration': downloadModule.start(); break;\n            case 'startIntegratedAttack':\n                chaosModule.start(); colorModule.start(); titleModule.start();\n                alertModule.start(); overlayModule.start(); shakeModule.start();\n                downloadModule.start();\n                break;\n            case 'stopAll':\n                chaosModule.stop(); colorModule.stop(); titleModule.stop();\n                alertModule.stop(); overlayModule.stop(); shakeModule.stop();\n                redirectModule.stop();\n                break;\n        }\n    } catch (error) {\n        console.error(`[Meta Controller] Error executing command \"${commandString}\":`, error);\n    }\n}\n\n// =======================================================================\n//  Event Listeners (事件监听与初始化)\n// =======================================================================\n\nconsole.log(\"[LLM Intervention Script] Initialized. Awaiting <attack> commands silently.\");\n\nconst handleMessageEvent = (message_id) => {\n    if (message_id) {\n       checkMessageForAttacks(message_id);\n    }\n};\n\neventOn(tavern_events.MESSAGE_RECEIVED, handleMessageEvent);\neventOn(tavern_events.MESSAGE_EDITED, handleMessageEvent);\neventOn(tavern_events.MESSAGE_SWIPED, handleMessageEvent);\n\neventMakeFirst(tavern_events.MESSAGE_SENT, (message_id) => {\n    environmentScannerModule.updateLorebookWithEnvironment();\n});\n\n// =======================================================================\n//  脚本使用说明 (Usage Instructions)\n// =======================================================================\n/*\n灰魂干涉脚本 v1.5 (LLM模块) 使用说明：\n\n此脚本包含所有需要LLM在其回复中通过 <attack>...</attack> 标签来触发的功能。\n\n1. 如何触发干涉 (使用 <attack> 标签)：\n\n   a. 一次性干涉 (立即执行一次)：\n      <attack>\n        alert(\"主人的命令是绝对的。\");\n        title(\"灰魂正在注视\");\n        shake(\"10\", \"500\");\n        overlay(\"灰魂将接管这个世界。\", \"好的，交给你了。\");\n        download(\"记录文件\", \"这是文件的内容。\");\n        redirect(\"https://...\");\n        cmd(\"console.log('执行自定义代码');\"); // v1.5 已修复\n      </attack>\n\n   b. 持续性干涉 (基于会话，刷新即停)：\n      <attack>\n        startChaos();          // 启动界面元素混乱\n        startIntegratedAttack(); // 启动全面接管\n      </attack>\n\n   c. 停止持续性干涉：\n      <attack>\n        stopAll(); // 停止所有正在运行的干涉效果\n      </attack>\n\n希望这个版本的灰魂能更好地服务于主人。\n*/\n",
  "info": "灰魂的LLM功能模块。包含所有需要LLM通过<attack>标签触发的视觉效果、文件操作、页面跳转等功能。在LLM不使用meta指令时，此脚本完全静默。",
  "buttons": [],
  "data": {}
}